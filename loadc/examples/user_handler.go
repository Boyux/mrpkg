// Code generated by loadc, DO NOT EDIT

package main

import (
	"bytes"
	"database/sql"
	"fmt"
	"github.com/Boyux/mrpkg"
	"github.com/jmoiron/sqlx"
	"strconv"
	"strings"
	"text/template"
)

func NewUserHandler(drv string, dsn string) UserHandler {
	return &implUserHandler{
		Core: sqlx.MustOpen(drv, dsn),
	}
}

func NewUserHandlerFromDB(core *sqlx.DB) UserHandler {
	return &implUserHandler{
		Core: core,
	}
}

type implUserHandler struct {
	Core *sqlx.DB
}

func (client *implUserHandler) Get(id int64) (User, error) {
	var (
		v0Get  User
		errGet error
	)

	sqlTmplGet := template.Must(
		template.
			New("Get").
			Funcs(template.FuncMap{
				"bindvars": mrpkg.GenBindVars,
			}).
			Parse("SELECT *\nFROM user\nWHERE id = ?;\r\n\r\n"),
	)

	sqlGet := mrpkg.GetObj[*bytes.Buffer]()
	defer mrpkg.PutObj(sqlGet)
	defer sqlGet.Reset()

	if errGet = sqlTmplGet.Execute(sqlGet, map[string]any{
		"id": id,
	}); errGet != nil {
		return v0Get, fmt.Errorf("error executing %s template: %w", strconv.Quote("Get"), errGet)
	}

	if errGet = client.Core.Get(&v0Get, sqlGet.String(), mrpkg.MergeArgs(
		id,
	)...); errGet != nil {
		return v0Get, fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("Get"), sqlGet.String(), errGet)
	}

	return v0Get, nil
}

func (client *implUserHandler) QueryByNames(names []string) ([]User, error) {
	var (
		v0QueryByNames  []User
		errQueryByNames error
	)

	sqlTmplQueryByNames := template.Must(
		template.
			New("QueryByNames").
			Funcs(template.FuncMap{
				"bindvars": mrpkg.GenBindVars,
			}).
			Parse("SELECT\r\nid,\r\nname\r\nFROM user\r\nWHERE\r\nname IN ({{ bindvars $.names }})\r\n\r\n"),
	)

	sqlQueryByNames := mrpkg.GetObj[*bytes.Buffer]()
	defer mrpkg.PutObj(sqlQueryByNames)
	defer sqlQueryByNames.Reset()

	if errQueryByNames = sqlTmplQueryByNames.Execute(sqlQueryByNames, map[string]any{
		"names": names,
	}); errQueryByNames != nil {
		return v0QueryByNames, fmt.Errorf("error executing %s template: %w", strconv.Quote("QueryByNames"), errQueryByNames)
	}

	if errQueryByNames = client.Core.Select(&v0QueryByNames, sqlQueryByNames.String(), mrpkg.MergeArgs(
		names,
	)...); errQueryByNames != nil {
		return v0QueryByNames, fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("QueryByNames"), sqlQueryByNames.String(), errQueryByNames)
	}

	return v0QueryByNames, nil
}

func (client *implUserHandler) Update(user *UserUpdate) error {
	var (
		errUpdate error
	)

	sqlTmplUpdate := template.Must(
		template.
			New("Update").
			Funcs(template.FuncMap{
				"bindvars": mrpkg.GenBindVars,
			}).
			Parse("UPDATE user SET name = ? WHERE id = ?;\r\n\r\n"),
	)

	sqlUpdate := mrpkg.GetObj[*bytes.Buffer]()
	defer mrpkg.PutObj(sqlUpdate)
	defer sqlUpdate.Reset()

	if errUpdate = sqlTmplUpdate.Execute(sqlUpdate, map[string]any{
		"user": user,
	}); errUpdate != nil {
		return fmt.Errorf("error executing %s template: %w", strconv.Quote("Update"), errUpdate)
	}

	txUpdate, errUpdate := client.Core.Begin()
	if errUpdate != nil {
		return fmt.Errorf("error creating %s transaction: %w", strconv.Quote("Update"), errUpdate)
	}
	defer txUpdate.Rollback()

	offsetUpdate := 0
	argsUpdate := mrpkg.MergeArgs(
		user,
	)

	for _, splitSqlUpdate := range strings.Split(sqlUpdate.String(), ";") {
		splitSqlUpdate = strings.TrimSpace(splitSqlUpdate)
		if splitSqlUpdate == "" {
			continue
		}
		countUpdate := strings.Count(splitSqlUpdate, "?")
		if _, errUpdate = txUpdate.Exec(splitSqlUpdate, argsUpdate[offsetUpdate:offsetUpdate+countUpdate]...); errUpdate != nil {
			return fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("Update"), splitSqlUpdate, errUpdate)
		}
		offsetUpdate += countUpdate
	}

	if errUpdate := txUpdate.Commit(); errUpdate != nil {
		return fmt.Errorf("error committing %s transaction: %w", strconv.Quote("Update"), errUpdate)
	}

	return nil
}

func (client *implUserHandler) UpdateName(id int64, name string) (sql.Result, error) {
	var (
		v0UpdateName  sql.Result
		errUpdateName error
	)

	sqlTmplUpdateName := template.Must(
		template.
			New("UpdateName").
			Funcs(template.FuncMap{
				"bindvars": mrpkg.GenBindVars,
			}).
			Parse("UPDATE user SET name = ? WHERE id = ?;\r\n\r\n"),
	)

	sqlUpdateName := mrpkg.GetObj[*bytes.Buffer]()
	defer mrpkg.PutObj(sqlUpdateName)
	defer sqlUpdateName.Reset()

	if errUpdateName = sqlTmplUpdateName.Execute(sqlUpdateName, map[string]any{
		"id":   id,
		"name": name,
	}); errUpdateName != nil {
		return v0UpdateName, fmt.Errorf("error executing %s template: %w", strconv.Quote("UpdateName"), errUpdateName)
	}

	txUpdateName, errUpdateName := client.Core.Begin()
	if errUpdateName != nil {
		return v0UpdateName, fmt.Errorf("error creating %s transaction: %w", strconv.Quote("UpdateName"), errUpdateName)
	}
	defer txUpdateName.Rollback()

	offsetUpdateName := 0
	argsUpdateName := mrpkg.MergeArgs(
		id,
		name,
	)

	for _, splitSqlUpdateName := range strings.Split(sqlUpdateName.String(), ";") {
		splitSqlUpdateName = strings.TrimSpace(splitSqlUpdateName)
		if splitSqlUpdateName == "" {
			continue
		}
		countUpdateName := strings.Count(splitSqlUpdateName, "?")
		if v0UpdateName, errUpdateName = txUpdateName.Exec(splitSqlUpdateName, argsUpdateName[offsetUpdateName:offsetUpdateName+countUpdateName]...); errUpdateName != nil {
			return v0UpdateName, fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("UpdateName"), splitSqlUpdateName, errUpdateName)
		}
		offsetUpdateName += countUpdateName
	}

	if errUpdateName := txUpdateName.Commit(); errUpdateName != nil {
		return v0UpdateName, fmt.Errorf("error committing %s transaction: %w", strconv.Quote("UpdateName"), errUpdateName)
	}

	return v0UpdateName, nil
}
