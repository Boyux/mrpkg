// Code generated by loadc, DO NOT EDIT

package main

import (
	"bytes"
	"fmt"
	"github.com/Boyux/mrpkg"
	"github.com/jmoiron/sqlx"
	"strconv"
	"text/template"
)

func NewUserService(drv string, dsn string) UserService {
	return &implUserService{
		Core: sqlx.MustOpen(drv, dsn),
	}
}

func NewUserServiceFromDB(core *sqlx.DB) UserService {
	return &implUserService{
		Core: core,
	}
}

type implUserService struct {
	Core *sqlx.DB
}

func (client *implUserService) Get(id int64) (User, error) {
	var (
		v0Get  User
		errGet error
	)

	sqlTmplGet := template.Must(
		template.
			New("Get").
			Funcs(template.FuncMap{
				"bindvars": mrpkg.GenBindVars,
			}).
			Parse("SELECT * FROM user WHERE id = ?;\r\n\r\n"),
	)

	sqlGet := mrpkg.GetObj[*bytes.Buffer]()
	defer mrpkg.PutObj(sqlGet)
	defer sqlGet.Reset()

	if errGet = sqlTmplGet.Execute(sqlGet, map[string]any{
		"id": id,
	}); errGet != nil {
		return v0Get, fmt.Errorf("error executing %s template: %w", strconv.Quote("Get"), errGet)
	}

	if errGet = client.Core.Select(&v0Get, sqlGet.String(), mrpkg.MergeArgs(
		id,
	)...); errGet != nil {
		return v0Get, fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("Get"), sqlGet.String(), errGet)
	}

	return v0Get, nil
}

func (client *implUserService) QueryByNames(names []string) ([]User, error) {
	var (
		v0QueryByNames  []User
		errQueryByNames error
	)

	sqlTmplQueryByNames := template.Must(
		template.
			New("QueryByNames").
			Funcs(template.FuncMap{
				"bindvars": mrpkg.GenBindVars,
			}).
			Parse("SELECT\r\nid,\r\nname\r\nFROM user\r\nWHERE\r\nname IN ({{ bindvars $.names }})\r\n\r\n"),
	)

	sqlQueryByNames := mrpkg.GetObj[*bytes.Buffer]()
	defer mrpkg.PutObj(sqlQueryByNames)
	defer sqlQueryByNames.Reset()

	if errQueryByNames = sqlTmplQueryByNames.Execute(sqlQueryByNames, map[string]any{
		"names": names,
	}); errQueryByNames != nil {
		return v0QueryByNames, fmt.Errorf("error executing %s template: %w", strconv.Quote("QueryByNames"), errQueryByNames)
	}

	if errQueryByNames = client.Core.Select(&v0QueryByNames, sqlQueryByNames.String(), mrpkg.MergeArgs(
		names,
	)...); errQueryByNames != nil {
		return v0QueryByNames, fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("QueryByNames"), sqlQueryByNames.String(), errQueryByNames)
	}

	return v0QueryByNames, nil
}

func (client *implUserService) Update(user *UserUpdate) error {
	var (
		errUpdate error
	)

	sqlTmplUpdate := template.Must(
		template.
			New("Update").
			Funcs(template.FuncMap{
				"bindvars": mrpkg.GenBindVars,
			}).
			Parse("UPDATE user SET name = ? WHERE id = ?;\r\n\r\n"),
	)

	sqlUpdate := mrpkg.GetObj[*bytes.Buffer]()
	defer mrpkg.PutObj(sqlUpdate)
	defer sqlUpdate.Reset()

	if errUpdate = sqlTmplUpdate.Execute(sqlUpdate, map[string]any{
		"user": user,
	}); errUpdate != nil {
		return fmt.Errorf("error executing %s template: %w", strconv.Quote("Update"), errUpdate)
	}

	if _, errUpdate = client.Core.Exec(sqlUpdate.String(), mrpkg.MergeArgs(
		user,
	)...); errUpdate != nil {
		return fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("Update"), sqlUpdate.String(), errUpdate)
	}

	return nil
}

func (client *implUserService) UpdateName(id int64, name string) error {
	var (
		errUpdateName error
	)

	sqlTmplUpdateName := template.Must(
		template.
			New("UpdateName").
			Funcs(template.FuncMap{
				"bindvars": mrpkg.GenBindVars,
			}).
			Parse("UPDATE user SET name = ? WHERE id = ?;\r\n\r\n"),
	)

	sqlUpdateName := mrpkg.GetObj[*bytes.Buffer]()
	defer mrpkg.PutObj(sqlUpdateName)
	defer sqlUpdateName.Reset()

	if errUpdateName = sqlTmplUpdateName.Execute(sqlUpdateName, map[string]any{
		"id":   id,
		"name": name,
	}); errUpdateName != nil {
		return fmt.Errorf("error executing %s template: %w", strconv.Quote("UpdateName"), errUpdateName)
	}

	if _, errUpdateName = client.Core.Exec(sqlUpdateName.String(), mrpkg.MergeArgs(
		id,
		name,
	)...); errUpdateName != nil {
		return fmt.Errorf("error executing %s sql: \n\n%s\n\n%w", strconv.Quote("UpdateName"), sqlUpdateName.String(), errUpdateName)
	}

	return nil
}
